levels(t_iris$db) <- db_match(t_iris, t_iris$db)
t_iris %>% filter(dbc == 1)
t_iris[dbc == 1]
t_iris[,dbc == 1]
dbc
dbc$cluster
t_iris[dbc$cluster == 1]
t_iris[1,dbc$cluster == 1]
t_iris[,dbc$cluster == 1]
t_iris[dbc$cluster == 1,]
db_match <- function(df, dbc) {
labs <- c("outlier")
# Number of clusters
k <- length(unique(dbc)) - 1
for (i in 1:k) {
# Determine which label occurs the most
tab <- df[dbc == i,] %>% count(true)
ind_max <- which.max(tab %>% pull(n))
labs <- append(labs, as.character((tab$true)[ind_max]))
}
return(labs)
}
# Associate clusters with labels
levels(t_iris$db) <- db_match(t_iris, t_iris$db)
db_match(t_iris, t_iris$db)
t_iris[dbc$cluster == 1,]
t_iris[dbc$cluster == 1,] %>% count(true)
x < - t_iris[dbc$cluster == 2,] %>% count(true)
x <- t_iris[dbc$cluster == 2,] %>% count(true)
which.max(x %>% pull(n))
as.character((x$true)[1])
db_match <- function(df, dbc) {
labs <- c("outlier")
# Number of clusters
k <- length(unique(dbc)) - 1
for (i in 1:k) {
# Determine which label occurs the most
tab <- df[dbc == i,] %>% count(true)
ind_max <- which.max(tab %>% pull(n))
labs <- append(labs, as.character((tab$true)[ind_max]))
}
return(labs)
}
db_misclass <- function(df, dbc) {
# Match clusters to labels
levels(dbc) <- db_match(df, dbc)
levels(df$true) <- c(levels(dg$true), "outlier")
# Append any missing true labels to cluster levels
levels(dbc) <- c(levels(dbc), as.vector(unique(df$true)))
cm <- table(dbc, df$true, dnn = c("cluster", "true"))
cm <- cm[,c(4,1,2,3)]
return(list(
conf_mat = cm,
misclass = mean(dbc != df$true)
))
}
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(tidyverse, dbscan, GGally)
data(iris)
iris
# Scale and center
s_iris <- scale(iris[,1:4])
# Arrange in Tibble
t_iris <- as_tibble(s_iris) %>% add_column(true = iris$Species)
t_iris
# k-distance graph
k <- 5
kNNdistplot(t_iris[,1:4], k)
# Estimate of epsilon
eps <- 0.8
abline(h = eps, lty = 2 )
# IMPROVE
set.seed(215)
dbc <- dbscan(t_iris[,1:4], eps, minPts = 5)
dbc
t_iris <- t_iris %>% add_column(db = as.factor(dbc$cluster))
# Scatter plots
t_iris %>% ggpairs(columns = 1:4, aes(colour = db, alpha = 0.4)) + theme(legend.position = "bottom")
# Hull plot with first two principal
hull <- t_iris %>% slice(chull(true, db))
pca_res <- prcomp(t_iris[,1:4], scale. = FALSE)
p <- autoplot(pca_res, data = t_iris) + geom_point(shape = 21)
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(tidyverse, dbscan, GGally, ggfortify)
data(iris)
iris
# Scale and center
s_iris <- scale(iris[,1:4])
# Arrange in Tibble
t_iris <- as_tibble(s_iris) %>% add_column(true = iris$Species)
t_iris
# k-distance graph
k <- 5
kNNdistplot(t_iris[,1:4], k)
# Estimate of epsilon
eps <- 0.8
abline(h = eps, lty = 2 )
# IMPROVE
set.seed(215)
dbc <- dbscan(t_iris[,1:4], eps, minPts = 5)
dbc
t_iris <- t_iris %>% add_column(db = as.factor(dbc$cluster))
# Scatter plots
t_iris %>% ggpairs(columns = 1:4, aes(colour = db, alpha = 0.4)) + theme(legend.position = "bottom")
# Hull plot with first two principal
hull <- t_iris %>% slice(chull(true, db))
pca_res <- prcomp(t_iris[,1:4], scale. = FALSE)
p <- autoplot(pca_res, data = t_iris) + geom_point(shape = 21)
hullplot(t_iris[,1:4], dbc$cluster, pch = as.numeric(t_iris$true))
legend(-3,3, legend = c("0", "1", "2"))
db_match <- function(df, dbc) {
labs <- c("outlier")
# Number of clusters
k <- length(unique(dbc)) - 1
for (i in 1:k) {
# Determine which label occurs the most
tab <- df[dbc == i,] %>% count(true)
ind_max <- which.max(tab %>% pull(n))
labs <- append(labs, as.character((tab$true)[ind_max]))
}
return(labs)
}
db_misclass <- function(df, dbc) {
# Match clusters to labels
levels(dbc) <- db_match(df, dbc)
levels(df$true) <- c(levels(dg$true), "outlier")
# Append any missing true labels to cluster levels
levels(dbc) <- c(levels(dbc), as.vector(unique(df$true)))
cm <- table(dbc, df$true, dnn = c("cluster", "true"))
cm <- cm[,c(4,1,2,3)]
return(list(
conf_mat = cm,
misclass = mean(dbc != df$true)
))
}
# Confusion matrix
misclass(t_iris, t_iris$db)
# Confusion matrix
db_misclass(t_iris, t_iris$db)
db_misclass <- function(df, dbc) {
# Match clusters to labels
levels(dbc) <- db_match(df, dbc)
levels(df$true) <- c(levels(df$true), "outlier")
# Append any missing true labels to cluster levels
levels(dbc) <- c(levels(dbc), as.vector(unique(df$true)))
cm <- table(dbc, df$true, dnn = c("cluster", "true"))
cm <- cm[,c(4,1,2,3)]
return(list(
conf_mat = cm,
misclass = mean(dbc != df$true)
))
}
# Confusion matrix
db_misclass(t_iris, t_iris$db)
t_iris %>% pull(true)
t_iris[,1:4]
dbc <- dbscan(t_iris[,1:4], 1.5, minPts = 5)
hullplot(t_iris[,1:4], dbc$cluster, pch = as.numeric(t_iris$true))
db_misclass(t_iris, dbc$cluster)
levels(dbc$cluster) <- c(levels(dbc$cluster), as.vector(unique(t_iris$true)))
dbc$cluster
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(tidyverse, dbscan, GGally, ggfortify)
data(iris)
iris
# Scale and center
s_iris <- scale(iris[,1:4])
# Arrange in Tibble
t_iris <- as_tibble(s_iris) %>% add_column(true = iris$Species)
t_iris
# k-distance graph
k <- 5
kNNdistplot(t_iris[,1:4], k)
# Estimate of epsilon
eps <- 0.8
abline(h = eps, lty = 2 )
# IMPROVE
set.seed(215)
dbc <- dbscan(t_iris[,1:4], eps, minPts = 5)
dbc
t_iris <- t_iris %>% add_column(db = as.factor(dbc$cluster))
# Scatter plots
t_iris %>% ggpairs(columns = 1:4, aes(colour = db, alpha = 0.4)) + theme(legend.position = "bottom")
# Hull plot with first two principal
hull <- t_iris %>% slice(chull(true, db))
pca_res <- prcomp(t_iris[,1:4], scale. = FALSE)
p <- autoplot(pca_res, data = t_iris) + geom_point(shape = 21)
hullplot(t_iris[,1:4], dbc$cluster, pch = as.numeric(t_iris$true))
legend(-3,3, legend = c("0", "1", "2"))
db_match <- function(df, dbc) {
# Check if outliers have been marked
if (0 %in% unique(dbc)) {
labs <- c("outlier")
} else {
labs <- c()
}
# Number of clusters
k <- length(unique(dbc)) - 1
for (i in 1:k) {
# Determine which label occurs the most
tab <- df[dbc == i,] %>% count(true)
ind_max <- which.max(tab %>% pull(n))
labs <- append(labs, as.character((tab$true)[ind_max]))
}
return(labs)
}
db_misclass <- function(df, dbc) {
# Match clusters to labels
levels(dbc) <- db_match(df, dbc)
if (0 %in% unique(dbc)) {
levels(df$true) <- c(levels(df$true), "outlier")
}
# Append any missing true labels to cluster levels
levels(dbc) <- c(levels(dbc), as.vector(unique(df$true)))
print(dbc)
cm <- table(dbc, df$true, dnn = c("cluster", "true"))
if (0 %in% unique(dbc)) {
# Reorder columns to have "outlier" first
cm <- cm[,c(4,1,2,3)]
}
return(list(
conf_mat = cm,
misclass = mean(dbc != df$true)
))
}
# Confusion matrix
db_misclass(t_iris, t_iris$db)
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(tidyverse, dbscan, GGally, ggfortify, patchwork)
data(iris)
# Scale and center
s_iris <- scale(iris[,1:4])
# Arrange in Tibble
t_iris <- as_tibble(s_iris) %>% add_column(true = iris$Species)
t_iris
# k-distance graph
k <- 5
kNNdistplot(t_iris[,1:4], k)
# Estimate of epsilon
eps <- 0.8
abline(h = eps, lty = 2)
set.seed(215)
dbc <- dbscan(t_iris[,1:4], eps, minPts = 5)
dbc
t_iris <- t_iris %>% add_column(db = as.factor(dbc$cluster))
# Scatter plots
p1 <- t_iris %>% ggplot(aes(Sepal.Length, Sepal.Width, colour = db)) + geom_point()
p2 <- t_iris %>% ggplot(aes(Sepal.Length, Petal.Length, colour = db)) + geom_point()
p3 <- t_iris %>% ggplot(aes(Sepal.Length, Petal.Width, colour = db)) + geom_point()
p4 <- t_iris %>% ggplot(aes(Sepal.Width, Petal.Length, colour = db)) + geom_point()
p5 <- t_iris %>% ggplot(aes(Sepal.Width, Petal.Width, colour = db)) + geom_point()
p6 <- t_iris %>% ggplot(aes(Petal.Length, Petal.Width, colour = db)) + geom_point()
((p1 + p2)/(p3 + p4))/(p5 + p6)
# Hull plot with first two principal components
hullplot(t_iris[,1:4], dbc$cluster, pch = as.numeric(t_iris$true))
db_match <- function(df, dbc) {
# Number of clusters
k <- length(unique(dbc))
# Check if outliers have been marked
if (0 %in% unique(dbc)) {
labs <- c("outlier")
k < k - 1
} else {
labs <- c()
}
for (i in 1:k) {
# Determine which label occurs the most
tab <- df[dbc == i,] %>% count(true)
ind_max <- which.max(tab %>% pull(n))
labs <- append(labs, as.character((tab$true)[ind_max]))
}
return(labs)
}
db_misclass <- function(df, dbc) {
is_outliers <- FALSE
if (0 %in% unique(dbc)) {
levels(df$true) <- c(levels(df$true), "outlier")
is_outliers <- TRUE
}
# Match clusters to labels
dbc <- factor(dbc, labels = db_match(df, dbc))
# Append any missing true labels to cluster levels
levels(dbc) <- c(levels(dbc), setdiff(unique(df$true), levels(dbc)))
cm <- table(dbc, df$true, dnn = c("cluster", "true"))
if (is_outliers) {
# Reorder columns to have "outlier" first
cm <- cm[,c(4,1,2,3)]
}
return(list(
conf_mat = cm,
misclass = mean(dbc != df$true)
))
}
# Confusion matrix
db_misclass(t_iris, t_iris$db)
# DBSCAN with eps = 1.5
dbc <- dbscan(t_iris[,1:4], 1.5, minPts = 5)
hullplot(t_iris[,1:4], dbc$cluster, pch = as.numeric(t_iris$true))
# Confusion matrix
db_misclass(t_iris, as.factor(dbc$cluster))
# DBSCAN with eps = 0.5
dbc <- dbscan(t_iris[,1:4], 0.5, minPts = 5)
hullplot(t_iris[,1:4], dbc$cluster, pch = as.numeric(t_iris$true))
# Confusion matrix
db_misclass(t_iris, as.factor(dbc$cluster))
# DBSCAN with eps = 0.4
dbc <- dbscan(t_iris[,1:4], 0.4, minPts = 5)
hullplot(t_iris[,1:4], dbc$cluster, pch = as.numeric(t_iris$true))
# Confusion matrix
db_misclass(t_iris, as.factor(dbc$cluster))
km2 <- kmeans(t_iris[,1:4], 2)
hullplot(t_iris[,1:4], km2$cluster, pch = as.numeric(t_iris$true))
db_misclass(t_iris, km2$cluster)
km3 <- kmeans(t_iris[,1:4], 3)
hullplot(t_iris[,1:4], km3$cluster, pch = as.numeric(t_iris$true))
db_misclass(t_iris, km3$cluster)
km6 <- kmeans(t_iris[,1:4], 6)
hullplot(t_iris[,1:4], km6$cluster, pch = as.numeric(t_iris$true))
db_misclass(t_iris, km6$cluster)
FactMixtAnalysis::misc(dbc$cluster, t_iris$true)
install.packages("FactMixtAnalysis")
FactMixtAnalysis::misc(dbc$cluster, t_iris$true)
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(tidyverse, dbscan, GGally, ggfortify, patchwork)
data(iris)
# Scale and center
s_iris <- scale(iris[,1:4])
# Arrange in Tibble
t_iris <- as_tibble(s_iris) %>% add_column(true = iris$Species)
t_iris
# k-distance graph
k <- 5
kNNdistplot(t_iris[,1:4], k)
# Estimate of epsilon
eps <- 0.8
abline(h = eps, lty = 2)
set.seed(215)
dbc <- dbscan(t_iris[,1:4], eps, minPts = 5)
dbc
t_iris <- t_iris %>% add_column(db = as.factor(dbc$cluster))
# Scatter plots
p1 <- t_iris %>% ggplot(aes(Sepal.Length, Sepal.Width, colour = db)) + geom_point()
p2 <- t_iris %>% ggplot(aes(Sepal.Length, Petal.Length, colour = db)) + geom_point()
p3 <- t_iris %>% ggplot(aes(Sepal.Length, Petal.Width, colour = db)) + geom_point()
p4 <- t_iris %>% ggplot(aes(Sepal.Width, Petal.Length, colour = db)) + geom_point()
p5 <- t_iris %>% ggplot(aes(Sepal.Width, Petal.Width, colour = db)) + geom_point()
p6 <- t_iris %>% ggplot(aes(Petal.Length, Petal.Width, colour = db)) + geom_point()
((p1 + p2)/(p3 + p4))/(p5 + p6)
# Hull plot with first two principal components
hullplot(t_iris[,1:4], dbc$cluster, pch = as.numeric(t_iris$true))
db_match <- function(df, dbc) {
# Number of clusters
k <- length(unique(dbc))
# Check if outliers have been marked
if (0 %in% unique(dbc)) {
labs <- c("outlier")
k < k - 1
} else {
labs <- c()
}
for (i in 1:k) {
# Determine which label occurs the most
tab <- df[dbc == i,] %>% count(true)
ind_max <- which.max(tab %>% pull(n))
labs <- append(labs, as.character((tab$true)[ind_max]))
}
return(labs)
}
db_misclass <- function(df, dbc) {
is_outliers <- FALSE
if (0 %in% unique(dbc)) {
levels(df$true) <- c(levels(df$true), "outlier")
is_outliers <- TRUE
}
# Match clusters to labels
dbc <- factor(dbc, labels = db_match(df, dbc))
# Append any missing true labels to cluster levels
levels(dbc) <- c(levels(dbc), setdiff(unique(df$true), levels(dbc)))
cm <- table(dbc, df$true, dnn = c("cluster", "true"))
if (is_outliers) {
# Reorder columns to have "outlier" first
cm <- cm[,c(4,1,2,3)]
}
return(list(
conf_mat = cm,
misclass = mean(dbc != df$true),
FactMixAnalysis_misclass = FactMixtAnalysis::misc(dbc, df$true)
))
}
# Confusion matrix
db_misclass(t_iris, t_iris$db)
# DBSCAN with eps = 1.5
dbc <- dbscan(t_iris[,1:4], 1.5, minPts = 5)
hullplot(t_iris[,1:4], dbc$cluster, pch = as.numeric(t_iris$true))
# Confusion matrix
db_misclass(t_iris, as.factor(dbc$cluster))
# DBSCAN with eps = 0.5
dbc <- dbscan(t_iris[,1:4], 0.5, minPts = 5)
hullplot(t_iris[,1:4], dbc$cluster, pch = as.numeric(t_iris$true))
# Confusion matrix
db_misclass(t_iris, as.factor(dbc$cluster))
# DBSCAN with eps = 0.4
dbc <- dbscan(t_iris[,1:4], 0.4, minPts = 5)
hullplot(t_iris[,1:4], dbc$cluster, pch = as.numeric(t_iris$true))
# Confusion matrix
db_misclass(t_iris, as.factor(dbc$cluster))
km2 <- kmeans(t_iris[,1:4], 2)
hullplot(t_iris[,1:4], km2$cluster, pch = as.numeric(t_iris$true))
db_misclass(t_iris, km2$cluster)
km3 <- kmeans(t_iris[,1:4], 3)
hullplot(t_iris[,1:4], km3$cluster, pch = as.numeric(t_iris$true))
db_misclass(t_iris, km3$cluster)
km6 <- kmeans(t_iris[,1:4], 6)
hullplot(t_iris[,1:4], km6$cluster, pch = as.numeric(t_iris$true))
db_misclass(t_iris, km6$cluster)
hullplot(t_iris[,1:4], km6$cluster, pch = as.numeric(t_iris$true))
# Scatter plots
p1 <- t_iris %>% ggplot(aes(Sepal.Length, Sepal.Width, colour = db, shape = true)) + geom_point()
((p1 + p2)/(p3 + p4))/(p5 + p6)
# Scatter plots
p1 <- t_iris %>% ggplot(aes(Sepal.Length, Sepal.Width, colour = db, shape = true)) + geom_point()
p2 <- t_iris %>% ggplot(aes(Sepal.Length, Petal.Length, colour = db, shape = true)) + geom_point()
p3 <- t_iris %>% ggplot(aes(Sepal.Length, Petal.Width, colour = db, shape = true)) + geom_point()
p4 <- t_iris %>% ggplot(aes(Sepal.Width, Petal.Length, colour = db, shape = true)) + geom_point()
p5 <- t_iris %>% ggplot(aes(Sepal.Width, Petal.Width, colour = db, shape = true)) + geom_point()
p6 <- t_iris %>% ggplot(aes(Petal.Length, Petal.Width, colour = db, shape = true)) + geom_point()
((p1 + p2)/(p3 + p4))/(p5 + p6)
# Scatter plots
p1 <- t_iris %>% ggplot(aes(Sepal.Length, Sepal.Width, colour = db, shape = true)) + geom_point(show.legend = FALSE)
p2 <- t_iris %>% ggplot(aes(Sepal.Length, Petal.Length, colour = db, shape = true)) + geom_point(show.legend = FALSE)
p3 <- t_iris %>% ggplot(aes(Sepal.Length, Petal.Width, colour = db, shape = true)) + geom_point(show.legend = FALSE)
p4 <- t_iris %>% ggplot(aes(Sepal.Width, Petal.Length, colour = db, shape = true)) + geom_point(show.legend = FALSE)
p5 <- t_iris %>% ggplot(aes(Sepal.Width, Petal.Width, colour = db, shape = true)) + geom_point(show.legend = FALSE)
p6 <- t_iris %>% ggplot(aes(Petal.Length, Petal.Width, colour = db, shape = true)) + geom_point(show.legend = TRUE)
((p1 + p2)/(p3 + p4))/(p5 + p6)
knitr::opts_chunk$set(echo = TRUE,
root.dir = "C:/Users/liaml/Dropbox/Advanced Mathematical Perspectives/code")
pacman::p_load(tidyverse, janitor, ggfortify, GGally, skimr, patchwork)
cyto <- read.csv("../data/Data1.csv")
labels <- read.csv("../data/Labels1.csv")
cells <- tibble(cyto, labels)
# Clean column names automatically
cells <- janitor::clean_names(cells)
# Convert label column to factor
cells <- cells %>% mutate_at("labels", as.factor)
cells
skim_without_charts(cells) %>% knitr::kable(caption = "Summary of full dataset.", booktabs = TRUE)
skim_without_charts(cells %>% filter(labels == 0))  %>% knitr::kable(caption = "Summary of labelled dead cells (label 0).", booktabs = TRUE)
skim_without_charts(cells %>% filter(labels == 1)) %>% knitr::kable(caption = "Summary of cell population with label 1.", booktabs = TRUE)
skim_without_charts(cells %>% filter(labels == 2)) %>% knitr::kable(caption = "Summary of cell population with label 2.", booktabs = TRUE)
skim_without_charts(cells %>% filter(labels == 3)) %>% knitr::kable(caption = "Summary of cell population with label 3.", booktabs = TRUE)
skim_without_charts(cells %>% filter(labels == 4)) %>% knitr::kable(caption = "Summary of cell population with label 4.", booktabs = TRUE)
cells %>% ggplot(aes(fl1_log, fill = labels)) + geom_histogram(alpha = 0.5, position = "identity")
cells %>% ggplot(aes(fl2_log, fill = labels)) + geom_histogram(alpha = 0.5, position = "identity")
cells %>% ggplot(aes(fl4_log, fill = labels)) + geom_histogram(alpha = 0.5, position = "identity")
# PCA plots
pca_res <- prcomp(cells[3:5])
autoplot(pca_res, data = cells, alpha = 0.5, main = "Principal Component Analysis")
autoplot(pca_res, data = cells, colour = 'labels', alpha = 0.5, main = "Principal Component Analysis (Coloured by Manual Label)")
p1 <- cells %>% ggplot(aes(fl1_log, fl2_log, colour = labels), alpha = 0.5) + geom_point(alpha = 0.5)
p2 <- cells %>% ggplot(aes(fl1_log, fl4_log, colour = labels)) + geom_point(alpha = 0.5)
p3 <- cells %>% ggplot(aes(fl2_log, fl4_log, colour = labels)) + geom_point(alpha = 0.5)
(p1 + p2)/(p3 + plot_spacer()) + ggtitle("Fluorescent Measurements Marked by Label")
pacman::p_load(tidyverse, tidymodels, tidytuesdayR)
spotify <- tt_load("2020-01-21")
spotify
# Select relevant columns
songs <- spotify$spotify_songs %>% select(track_popularity, playlist_genre, playlist_subgenre, danceability:duration_ms)
rm_udrscr <- function(str) {
# Find location of _ in string
ind <- regexpr("_", str)
# Return the string after this index
return(substr(str, ind + 1, nchar(str)))
}
# Change column names containing _ to make my life easier
songs <- songs %>% rename_at(vars(contains("_")), rm_udrscr)
songs <- songs %>% rename(duration = ms)
# Convert appropriate columns to factors
songs <- songs %>% mutate_at(c("genre", "subgenre", "key", "mode"), as.factor)
# Remove genre
songs <- select(songs, -genre)
# Split data
songs_split <- initial_split(songs, strata = popularity)
songs_train <- training(songs_split)
songs_test <- testing(songs_split)
# Recipe
songs_recipe <- recipe(popularity ~ ., data = songs_train)
songs_recipe <- songs_recipe %>%
step_dummy(all_nominal()) %>%
step_normalize(all_predictors())
# Lasso model
songs_model <- linear_reg(mode = "regression", mixture = 1) %>%
set_engine("glmnet")
# Workflow
songs_wf <- workflow() %>%
add_recipe(songs_recipe) %>%
add_model(songs_model)
# A little EDA
skimr::skim(songs)
setwd("~/Projects/TestMatch/data/delivery")
cric <- read_csv('bbb_full.csv')
cric <- read_csv('bbb_full.csv')
pacman::p_load(tidyverse)
cric <- read_csv('bbb_full.csv')
cric <- cric %>% mutate_if(is.character, as.factor)
table(cric$Outcome)
plot(BatAvg, outcome)
cric %>% plot(BatAvg, outcome)
cric %>% plot(BatAvg, Outcome)
cric %>% plot(BatAvg ~ Outcome)
cric %>% plot(BatSR ~ Outcome)
cric %>% plot(TeamLead ~ TeamWkts)
